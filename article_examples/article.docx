Глава 4. Частота и быстрое преобразование Фурье

     Если вы хотите найти секреты вселенной, подумайте об энергии, частоте и вибрации.

     Никола Тесла

Эта глава была написана в сотрудничестве с отцом SW, PW van der Walt.

Эта глава будет немного отличаться от формата остальной части книги. В частности, вы можете найти код в главе довольно скромным. Вместо этого мы хотим проиллюстрировать элегантный алгоритм быстрого преобразования Фурье (БПФ), который бесконечно полезен, реализован в SciPy и работает, конечно, на массивах NumPy.

Представляя частоту

Начнем с настройки некоторых стилей печати и импорта обычных подозреваемых:


# Make plots appear inline, set custom plotting style
%matplotlib inline
import matplotlib.pyplot as plt

import numpy as np

Дискретное1 преобразование Фурье (DFT) - это математический метод, используемый для преобразования временных или пространственных данных в данные частотной области. Частота является знакомым понятием из-за ее разговорной встречаемости на английском языке: самые низкие ноты, которые могут грохотать в ваших наушниках, составляют около 20 Гц, в то время как средний C на фортепиано составляет около 261,6 Гц; Герц, или колебания в секунду, в данном случае буквально относится к числу раз в секунду, с которым мембрана внутри наушников перемещается взад-вперед. Это, в свою очередь, создает сжатые воздушные импульсы, которые по прибытии на барабанную перепонку вызывают вибрацию с той же частотой. Итак, если вы берете простую периодическую функцию sin (10 × 2πt), вы можете просмотреть ее как волну:

    f = 10  # Frequency, in cycles per second, or Hertz
    f_s = 100  # Sampling rate, or number of measurements per second

    t = np.linspace(0, 2, 2 * f_s, endpoint=False)
    x = np.sin(f * 2 * np.pi * t)

    fig, ax = plt.subplots()
    ax.plot(t, x)
    ax.set_xlabel("Time [s]")
    ax.set_ylabel("Signal amplitude");
    plt.show()


Или вы можете эквивалентно представить его как повторяющийся сигнал с частотой 10 Гц (он повторяется каждые 1/10 секунды - период времени, который мы называем его периодом). Хотя мы естественным образом связываем частоту со временем, она также может быть применена к пространству. Например, фотография текстильных рисунков демонстрирует высокую пространственную частоту, тогда как небо или другие гладкие объекты имеют низкую пространственную частоту.

Давайте теперь рассмотрим нашу синусоиду с помощью DFT:

from scipy import fftpack

X = fftpack.fft(x)
freqs = fftpack.fftfreq(len(x)) * f_s

fig, ax = plt.subplots()

ax.stem(freqs, np.abs(X))
ax.set_xlabel('Frequency in Hertz [Hz]')
ax.set_ylabel('Frequency Domain (Spectrum) Magnitude')
ax.set_xlim(-f_s / 2, f_s / 2)
ax.set_ylim(-5, 110)
Мы видим, что выходные данные FFT представляют собой одномерный массив такой же формы, что и входные данные, содержащие комплексные значения. Все значения равны нулю, кроме двух записей. Традиционно мы визуализируем величину результата как график ствола, в котором высота каждого ствола соответствует базовому значению.

(Мы объясняем, почему вы видите положительные и отрицательные частоты позже в «Дискретных преобразованиях Фурье». Вы также можете обратиться к этому разделу для более глубокого обзора основополагающей математики.)

Преобразование Фурье переносит нас от времени к частотной области, и это, оказывается, имеет огромное количество применений. Быстрое преобразование Фурье (БПФ) представляет собой алгоритм для вычисления ДПФ; он достигает своей высокой скорости, сохраняя и повторно используя результаты вычислений по мере продвижения.

В этой главе мы рассмотрим несколько применений ДПФ, чтобы продемонстрировать, что БПФ можно применять к многомерным данным (а не только к одномерным измерениям) для достижения различных целей.

Иллюстрация: Спектрограмма Песни Птицы

Начнем с одного из самых распространенных приложений - преобразования звукового сигнала (состоящего из колебаний давления воздуха во времени) в спектрограмму. Возможно, вы видели спектрограммы на экране эквалайзера музыкального проигрывателя или даже на стереосистеме старой школы (Рисунок 4-1).














Если вы читаете бумажную версию этой книги, вам придется использовать свое воображение! Это выглядит примерно так: chee-chee-woorrrr-hee-hee cheet-wheet-hoorrr-chirrr-whi-wheo-wheo-wheo-wheo-wheo-wheo.

Поскольку мы понимаем, что не все бегло говорят по-птичьи, возможно, будет лучше, если мы визуализируем измерения, более известные как «сигнал», вместо этого.

Мы загружаем аудиофайл, который дает нам частоту дискретизации (количество измерений в секунду), а также аудиоданные в виде массива (N, 2) - два столбца, потому что это стереозапись.

from scipy.io import wavfile
rate, audio = wavfile.read('data/nightingale.wav')
Мы конвертируем в моно путем усреднения левого и правого каналов.

audio = np.mean(audio, axis=1)

Затем мы рассчитываем длину фрагмента и выводим аудио 

    N = audio.shape[0]
    L = N / rate

    # print(f'Audio length: {L:.2f} seconds')

    f, ax = plt.subplots()
    ax.plot(np.arange(N) / rate, audio)
    ax.set_xlabel('Time [s]')
    ax.set_ylabel('Amplitude [unknown]');
    plt.grid()
    plt.show()







Ну, это не очень приятно, не так ли? Если бы я послал это напряжение на динамик, я мог бы услышать щебетание птицы, но я не очень хорошо представляю, как это будет звучать в моей голове. Есть ли лучший способ увидеть, что происходит?

Существует, и это называется дискретным преобразованием Фурье, или ДПФ, где дискретный относится к записи, состоящей из измерений звука с разнесением во времени, в отличие от непрерывной записи, как, например, на магнитной ленте (помните кассеты?). ДПФ часто вычисляется с использованием алгоритма БПФ, имя, неофициально используемое для обозначения самого ДПФ. DFT сообщает нам, какие частоты или «ноты» следует ожидать в нашем сигнале.

Конечно, птица поет много нот на протяжении всей песни, поэтому мы также хотели бы знать, когда появляется каждая нота. Преобразование Фурье принимает сигнал во временной области (то есть набор измерений во времени) и превращает его в спектр - набор частот с соответствующими значениями (complex2). Спектр не содержит никакой информации о времени! 3

Итак, чтобы найти частоты и время, когда они были спеты, нам нужно быть несколько умным. Наша стратегия заключается в следующем: взять аудиосигнал, разбить его на маленькие перекрывающиеся фрагменты и применить преобразование Фурье к каждому (метод, известный как преобразование Фурье с коротким временем).

Мы разделим сигнал на фрагменты по 1024 сэмпла - это примерно 0,02 секунды звука. Причину, по которой мы выбрали 1024, а не 1000, мы расскажем через секунду, когда будем анализировать производительность. Срезы будут перекрываться на 100 образцов, как показано здесь:


Начните с разбивки сигнала на срезы по 1024 сэмпла, каждый из которых перекрывает предыдущий на 100 сэмплов. Полученный объект срезов содержит один срез на строку.

from skimage import util

M = 1024

slices = util.view_as_windows(audio, window_shape=(M,), step=100)

Сгенерируйте оконную функцию (см. «Оконное управление» для обсуждения основных предположений и интерпретаций каждого из них) и умножьте ее на сигнал:
win = np.hanning(M + 1)[:-1]
slices = slices * win
slices = slices.T
print('Shape of `slices`:', slices.shape)
Для каждого среза вычислите ДПФ, который возвращает как положительные, так и отрицательные частоты (подробнее об этом в разделе «Частоты и их порядок»), поэтому на данный момент мы выделяем положительные частоты М2.

spectrum = np.fft.fft(slices, axis=0)[:M // 2 + 1:-1]
spectrum = np.abs(spectrum)

(Кстати, вы заметите, что мы используем взаимозаменяемо scipy.fftpack.fft и np.fft. NumPy предоставляет базовую функциональность FFT, которая расширяет SciPy, но обе включают функцию fft, основанную на Fortran FFTPACK.)

Спектр может содержать как очень большие, так и очень маленькие значения. Принимая журнал значительно сжимает диапазон.

Здесь мы делаем логарифмическую зависимость отношения сигнала, деленного на максимальный сигнал (показано на рисунке 4-3). Конкретной единицей измерения, используемой для отношения, является децибел, 20log10 (отношение амплитуд).

f, ax = plt.subplots(figsize=(4.8, 2.4))

S = np.abs(spectrum)
S = 20 * np.log10(S / np.max(S))

ax.imshow(S, origin='lower', cmap='viridis',
          extent=(0, L, 0, rate / 2 / 1000))
ax.axis('tight')
ax.set_ylabel('Frequency [kHz]')
ax.set_xlabel('Time [s]');


Намного лучше! Теперь мы можем видеть, что частоты меняются со временем, и спектрограмма соответствует звучанию звука. Посмотрите, можете ли вы соответствовать нашему более раннему описанию: chee-chee-woorrrr-hee-hee cheet-wheet-hoorrr-chirrr-whi-wheo-wheo-wheo-wheo-wheo-wheo. (Я не транскрибировал метку от 3 до 5 секунд - это другая птица.)

SciPy уже включает реализацию этой процедуры в виде scipy.signal.spectrogram (рисунок 4-4), которая может быть вызвана следующим образом:
Единственные различия между созданной нами ручной спектрограммой и встроенной функцией SciPy состоят в том, что SciPy возвращает квадрат спектральной величины (который превращает измеренное напряжение в измеренную энергию) и умножает его на некоторые коэффициенты нормализации.4




история
Проследить точное происхождение преобразования Фурье довольно сложно. Некоторые связанные с этим процедуры уходят еще в вавилонские времена, но именно горячие темы расчета орбит астероидов и решения уравнения теплопроводности (потока) привели к нескольким прорывам в начале 1800-х годов. Кого именно из Клеро, Лагранжа, Эйлера, Гаусса и Даламбера мы должны благодарить, не совсем ясно, но Гаусс был первым, кто описал быстрое преобразование Фурье (алгоритм для вычисления ДПФ, популяризированный Кули и Тьюки в 1965 году) , Жозеф Фурье, в честь которого названо преобразование, впервые заявил, что произвольные периодические 5 функции могут быть выражены в виде суммы тригонометрических функций.
Реализация

Функциональность DFT в SciPy находится в модуле scipy.fftpack. Среди прочего, он предоставляет следующие функции, связанные с DFT:
	FFT, FFT2, FFTN
     Вычислите ДПФ, используя алгоритм БПФ в 1, 2 или n измерениях.

	ifft, ifft2, ifftn
     Вычислить обратное значение ДПФ.

	dct, idct, dst, idst
     Вычислить косинус и синусоидальные преобразования и их обратные.

	fftshift, ifftshift
     Сдвиньте компонент с нулевой частотой к центру спектра и обратно соответственно (подробнее об этом в ближайшее время).

	fftfreq
     Вернуть частоты дискретизации DFT.

 rfft
     Вычислите ДПФ реальной последовательности, используя симметрию результирующего спектра для повышения производительности. Также используется fft для внутренних целей, когда это применимо.

Этот список дополняется следующими функциями в NumPy:

np.hanning, np.hamming, np.bartlett, np.blackman, np.kaiser

     Конические оконные функции.

DFT также используется для быстрого свертывания больших входных данных с помощью scipy.signal.fftconvolve.

SciPy упаковывает библиотеку Fortran FFTPACK - она не самая быстрая, но в отличие от таких пакетов, как FFTW, она имеет бесплатную лицензию на бесплатное программное обеспечение.

Выбор длины ДПФ

Наивное вычисление DFT принимает (N2) операций. Ну, у вас есть N (комплексные) синусоиды разных частот (2πf × 0, 2πf × 1; 2πf × 3, ..., 2πf × (N - 1)), и вы хотите увидеть, насколько сильно ваш сигнал соответствует каждому , Начиная с первого, вы берете точечное произведение с сигналом (что само по себе влечет за собой N операций умножения). Повторение этой операции N раз, один раз для каждой синусоиды, затем дает N2 операций.

Теперь сопоставим это с БПФ, которое (N log N) в идеальном случае благодаря умному повторному использованию вычислений - большое улучшение! Тем не менее, классический алгоритм Кули-Тьюки, реализованный в FFTPACK (и используемый SciPy), рекурсивно разбивает преобразование на более мелкие (простые по размеру) куски и показывает это улучшение только для «гладких» длин ввода (длина ввода считается гладкой, когда его наибольший простой фактор мал, как показано на рисунке 4-5). Для больших кусков простого размера алгоритмы Bluestein или Rader могут использоваться в сочетании с алгоритмом Cooley-Tukey, но эта оптимизация не реализована в FFTPACK.7

Давайте проиллюстрируем:

import time

from scipy import fftpack
from sympy import factorint

K = 1000
lengths = range(250, 260)

# Calculate the smoothness for all input lengths
smoothness = [max(factorint(i).keys()) for i in lengths]


exec_times = []
for i in lengths:
    z = np.random.random(i)

    # For each input length i, execute the FFT K times
    # and store the execution time

    times = []
    for k in range(K):
        tic = time.monotonic()
        fftpack.fft(z)
        toc = time.monotonic()
        times.append(toc - tic)

    # For each input length, remember the *minimum* execution time
    exec_times.append(min(times))


f, (ax0, ax1) = plt.subplots(2, 1, sharex=True)
ax0.stem(lengths, np.array(exec_times) * 10**6)
ax0.set_ylabel('Execution time (µs)')

ax1.stem(lengths, smoothness)
ax1.set_ylabel('Smoothness of input length\n(lower is better)')
ax1.set_xlabel('Length of input');


Рисунок 4-5. Время выполнения БПФ в зависимости от гладкости для различной длины ввода

Интуиция заключается в том, что для гладких чисел БПФ можно разбить на множество маленьких кусочков. После выполнения БПФ на первом фрагменте мы можем использовать эти результаты в последующих вычислениях. Это объясняет, почему мы выбрали длину 1024 для наших звуковых фрагментов ранее - она ​​имеет гладкость всего 2, что приводит к оптимальному алгоритму «radix-2 Cooley-Tukey», который вычисляет БПФ с использованием только (N / 2) log2N = 5120 комплексных умножений вместо N2 = 1 048 576. Выбор N = 2m всегда обеспечивает максимально гладкое N (и, следовательно, самое быстрое БПФ).
Дополнительные концепции DFT

Далее мы представляем пару общих концепций, которые стоит знать перед эксплуатацией тяжелого механизма преобразования Фурье, после чего мы решаем еще одну реальную проблему: анализ обнаружения целей в радиолокационных данных.
Частоты и их порядок

По историческим причинам большинство реализаций возвращают массив, в котором частоты варьируются от низких до высоких к низким (см. «Дискретные преобразования Фурье» для дальнейшего объяснения частот). Например, когда мы выполняем реальное преобразование Фурье сигнала всех сигналов, вход, который не имеет изменений и поэтому имеет только самый медленный постоянный компонент Фурье (также известный как «постоянный ток» или постоянный ток, компонент - просто электроника). жаргон для «среднее значение сигнала»), в качестве первой записи:

from scipy import fftpack
N = 10
fftpack.fft(np.ones(N))  # The first component is np.mean(x) * N
Когда мы пробуем FFT на быстро меняющемся сигнале, мы видим высокочастотный компонент:

z = np.ones(10)
z[::2] = -1

print(f'Applying FFT to {z}')
fftpack.fft(z)
Обратите внимание, что БПФ возвращает сложный спектр, который в случае реальных входных сигналов является сопряженным симметричным (то есть симметричным в действительной части и антисимметричным в мнимой части):
x = np.array([1, 5, 12, 7, 3, 0, 4, 3, 2, 8])
X = fftpack.fft(x)

np.set_printoptions(precision=2)

print("Real part:     ", X.real)
print("Imaginary part:", X.imag)

np.set_printoptions()
(И, опять же, напомним, что первым компонентом является np.mean (x) * N.)

Функция fftfreq сообщает нам, на каких частотах мы смотрим
fftpack.fftfreq(10)

Результат говорит нам, что наш максимальный компонент происходил с частотой 0,5 цикла на образец. Это согласуется со входом, где цикл «минус один плюс один» повторяется для каждой второй выборки.

Иногда удобно рассматривать спектр, организованный немного по-другому, от высокого отрицательного к низкому к высокому положительному (на данный момент мы не будем слишком углубляться в понятие отрицательной частоты, кроме как сказать реальное мировая синусоида создается сочетанием положительных и отрицательных частот). Мы перетасовываем спектр, используя функцию fftshift.
