Глава 4. Частота и быстрое преобразование Фурье

     Если вы хотите найти секреты вселенной, подумайте об энергии, частоте и вибрации.

     Никола Тесла

Эта глава была написана в сотрудничестве с отцом SW, PW van der Walt.

Эта глава будет немного отличаться от формата остальной части книги. В частности, вы можете найти код в главе довольно скромным. Вместо этого мы хотим проиллюстрировать элегантный алгоритм быстрого преобразования Фурье (БПФ), который бесконечно полезен, реализован в SciPy и работает, конечно, на массивах NumPy.

Представляя частоту

Начнем с настройки некоторых стилей печати и импорта обычных подозреваемых:


# Make plots appear inline, set custom plotting style
%matplotlib inline
import matplotlib.pyplot as plt

import numpy as np

Дискретное1 преобразование Фурье (DFT) - это математический метод, используемый для преобразования временных или пространственных данных в данные частотной области. Частота является знакомым понятием из-за ее разговорной встречаемости на английском языке: самые низкие ноты, которые могут грохотать в ваших наушниках, составляют около 20 Гц, в то время как средний C на фортепиано составляет около 261,6 Гц; Герц, или колебания в секунду, в данном случае буквально относится к числу раз в секунду, с которым мембрана внутри наушников перемещается взад-вперед. Это, в свою очередь, создает сжатые воздушные импульсы, которые по прибытии на барабанную перепонку вызывают вибрацию с той же частотой. Итак, если вы берете простую периодическую функцию sin (10 × 2πt), вы можете просмотреть ее как волну:

    f = 10  # Frequency, in cycles per second, or Hertz
    f_s = 100  # Sampling rate, or number of measurements per second

    t = np.linspace(0, 2, 2 * f_s, endpoint=False)
    x = np.sin(f * 2 * np.pi * t)

    fig, ax = plt.subplots()
    ax.plot(t, x)
    ax.set_xlabel("Time [s]")
    ax.set_ylabel("Signal amplitude");
    plt.show()


Или вы можете эквивалентно представить его как повторяющийся сигнал с частотой 10 Гц (он повторяется каждые 1/10 секунды - период времени, который мы называем его периодом). Хотя мы естественным образом связываем частоту со временем, она также может быть применена к пространству. Например, фотография текстильных рисунков демонстрирует высокую пространственную частоту, тогда как небо или другие гладкие объекты имеют низкую пространственную частоту.

Давайте теперь рассмотрим нашу синусоиду с помощью DFT:

from scipy import fftpack

X = fftpack.fft(x)
freqs = fftpack.fftfreq(len(x)) * f_s

fig, ax = plt.subplots()

ax.stem(freqs, np.abs(X))
ax.set_xlabel('Frequency in Hertz [Hz]')
ax.set_ylabel('Frequency Domain (Spectrum) Magnitude')
ax.set_xlim(-f_s / 2, f_s / 2)
ax.set_ylim(-5, 110)
Мы видим, что выходные данные FFT представляют собой одномерный массив такой же формы, что и входные данные, содержащие комплексные значения. Все значения равны нулю, кроме двух записей. Традиционно мы визуализируем величину результата как график ствола, в котором высота каждого ствола соответствует базовому значению.

(Мы объясняем, почему вы видите положительные и отрицательные частоты позже в «Дискретных преобразованиях Фурье». Вы также можете обратиться к этому разделу для более глубокого обзора основополагающей математики.)

Преобразование Фурье переносит нас от времени к частотной области, и это, оказывается, имеет огромное количество применений. Быстрое преобразование Фурье (БПФ) представляет собой алгоритм для вычисления ДПФ; он достигает своей высокой скорости, сохраняя и повторно используя результаты вычислений по мере продвижения.

В этой главе мы рассмотрим несколько применений ДПФ, чтобы продемонстрировать, что БПФ можно применять к многомерным данным (а не только к одномерным измерениям) для достижения различных целей.

Иллюстрация: Спектрограмма Песни Птицы

Начнем с одного из самых распространенных приложений - преобразования звукового сигнала (состоящего из колебаний давления воздуха во времени) в спектрограмму. Возможно, вы видели спектрограммы на экране эквалайзера музыкального проигрывателя или даже на стереосистеме старой школы (Рисунок 4-1).














Если вы читаете бумажную версию этой книги, вам придется использовать свое воображение! Это выглядит примерно так: chee-chee-woorrrr-hee-hee cheet-wheet-hoorrr-chirrr-whi-wheo-wheo-wheo-wheo-wheo-wheo.

Поскольку мы понимаем, что не все бегло говорят по-птичьи, возможно, будет лучше, если мы визуализируем измерения, более известные как «сигнал», вместо этого.

Мы загружаем аудиофайл, который дает нам частоту дискретизации (количество измерений в секунду), а также аудиоданные в виде массива (N, 2) - два столбца, потому что это стереозапись.

from scipy.io import wavfile
rate, audio = wavfile.read('data/nightingale.wav')
Мы конвертируем в моно путем усреднения левого и правого каналов.

audio = np.mean(audio, axis=1)

Затем мы рассчитываем длину фрагмента и выводим аудио 

    N = audio.shape[0]
    L = N / rate

    # print(f'Audio length: {L:.2f} seconds')

    f, ax = plt.subplots()
    ax.plot(np.arange(N) / rate, audio)
    ax.set_xlabel('Time [s]')
    ax.set_ylabel('Amplitude [unknown]');
    plt.grid()
    plt.show()







Ну, это не очень приятно, не так ли? Если бы я послал это напряжение на динамик, я мог бы услышать щебетание птицы, но я не очень хорошо представляю, как это будет звучать в моей голове. Есть ли лучший способ увидеть, что происходит?

Существует, и это называется дискретным преобразованием Фурье, или ДПФ, где дискретный относится к записи, состоящей из измерений звука с разнесением во времени, в отличие от непрерывной записи, как, например, на магнитной ленте (помните кассеты?). ДПФ часто вычисляется с использованием алгоритма БПФ, имя, неофициально используемое для обозначения самого ДПФ. DFT сообщает нам, какие частоты или «ноты» следует ожидать в нашем сигнале.

Конечно, птица поет много нот на протяжении всей песни, поэтому мы также хотели бы знать, когда появляется каждая нота. Преобразование Фурье принимает сигнал во временной области (то есть набор измерений во времени) и превращает его в спектр - набор частот с соответствующими значениями (complex2). Спектр не содержит никакой информации о времени! 3

Итак, чтобы найти частоты и время, когда они были спеты, нам нужно быть несколько умным. Наша стратегия заключается в следующем: взять аудиосигнал, разбить его на маленькие перекрывающиеся фрагменты и применить преобразование Фурье к каждому (метод, известный как преобразование Фурье с коротким временем).

Мы разделим сигнал на фрагменты по 1024 сэмпла - это примерно 0,02 секунды звука. Причину, по которой мы выбрали 1024, а не 1000, мы расскажем через секунду, когда будем анализировать производительность. Срезы будут перекрываться на 100 образцов, как показано здесь:


Начните с разбивки сигнала на срезы по 1024 сэмпла, каждый из которых перекрывает предыдущий на 100 сэмплов. Полученный объект срезов содержит один срез на строку.

from skimage import util

M = 1024

slices = util.view_as_windows(audio, window_shape=(M,), step=100)

Сгенерируйте оконную функцию (см. «Оконное управление» для обсуждения основных предположений и интерпретаций каждого из них) и умножьте ее на сигнал:
win = np.hanning(M + 1)[:-1]
slices = slices * win
slices = slices.T
print('Shape of `slices`:', slices.shape)
Для каждого среза вычислите ДПФ, который возвращает как положительные, так и отрицательные частоты (подробнее об этом в разделе «Частоты и их порядок»), поэтому на данный момент мы выделяем положительные частоты М2.

spectrum = np.fft.fft(slices, axis=0)[:M // 2 + 1:-1]
spectrum = np.abs(spectrum)

(Кстати, вы заметите, что мы используем взаимозаменяемо scipy.fftpack.fft и np.fft. NumPy предоставляет базовую функциональность FFT, которая расширяет SciPy, но обе включают функцию fft, основанную на Fortran FFTPACK.)

Спектр может содержать как очень большие, так и очень маленькие значения. Принимая журнал значительно сжимает диапазон.

Здесь мы делаем логарифмическую зависимость отношения сигнала, деленного на максимальный сигнал (показано на рисунке 4-3). Конкретной единицей измерения, используемой для отношения, является децибел, 20log10 (отношение амплитуд).

f, ax = plt.subplots(figsize=(4.8, 2.4))

S = np.abs(spectrum)
S = 20 * np.log10(S / np.max(S))

ax.imshow(S, origin='lower', cmap='viridis',
          extent=(0, L, 0, rate / 2 / 1000))
ax.axis('tight')
ax.set_ylabel('Frequency [kHz]')
ax.set_xlabel('Time [s]');


Намного лучше! Теперь мы можем видеть, что частоты меняются со временем, и спектрограмма соответствует звучанию звука. Посмотрите, можете ли вы соответствовать нашему более раннему описанию: chee-chee-woorrrr-hee-hee cheet-wheet-hoorrr-chirrr-whi-wheo-wheo-wheo-wheo-wheo-wheo. (Я не транскрибировал метку от 3 до 5 секунд - это другая птица.)

SciPy уже включает реализацию этой процедуры в виде scipy.signal.spectrogram (рисунок 4-4), которая может быть вызвана следующим образом:
Единственные различия между созданной нами ручной спектрограммой и встроенной функцией SciPy состоят в том, что SciPy возвращает квадрат спектральной величины (который превращает измеренное напряжение в измеренную энергию) и умножает его на некоторые коэффициенты нормализации.4




история
Проследить точное происхождение преобразования Фурье довольно сложно. Некоторые связанные с этим процедуры уходят еще в вавилонские времена, но именно горячие темы расчета орбит астероидов и решения уравнения теплопроводности (потока) привели к нескольким прорывам в начале 1800-х годов. Кого именно из Клеро, Лагранжа, Эйлера, Гаусса и Даламбера мы должны благодарить, не совсем ясно, но Гаусс был первым, кто описал быстрое преобразование Фурье (алгоритм для вычисления ДПФ, популяризированный Кули и Тьюки в 1965 году) , Жозеф Фурье, в честь которого названо преобразование, впервые заявил, что произвольные периодические 5 функции могут быть выражены в виде суммы тригонометрических функций.
Реализация

Функциональность DFT в SciPy находится в модуле scipy.fftpack. Среди прочего, он предоставляет следующие функции, связанные с DFT:
	FFT, FFT2, FFTN
     Вычислите ДПФ, используя алгоритм БПФ в 1, 2 или n измерениях.

	ifft, ifft2, ifftn
     Вычислить обратное значение ДПФ.

	dct, idct, dst, idst
     Вычислить косинус и синусоидальные преобразования и их обратные.

	fftshift, ifftshift
     Сдвиньте компонент с нулевой частотой к центру спектра и обратно соответственно (подробнее об этом в ближайшее время).

	fftfreq
     Вернуть частоты дискретизации DFT.

 rfft
     Вычислите ДПФ реальной последовательности, используя симметрию результирующего спектра для повышения производительности. Также используется fft для внутренних целей, когда это применимо.

Этот список дополняется следующими функциями в NumPy:

np.hanning, np.hamming, np.bartlett, np.blackman, np.kaiser

     Конические оконные функции.

DFT также используется для быстрого свертывания больших входных данных с помощью scipy.signal.fftconvolve.

SciPy упаковывает библиотеку Fortran FFTPACK - она не самая быстрая, но в отличие от таких пакетов, как FFTW, она имеет бесплатную лицензию на бесплатное программное обеспечение.

Выбор длины ДПФ

Наивное вычисление DFT принимает (N2) операций. Ну, у вас есть N (комплексные) синусоиды разных частот (2πf × 0, 2πf × 1; 2πf × 3, ..., 2πf × (N - 1)), и вы хотите увидеть, насколько сильно ваш сигнал соответствует каждому , Начиная с первого, вы берете точечное произведение с сигналом (что само по себе влечет за собой N операций умножения). Повторение этой операции N раз, один раз для каждой синусоиды, затем дает N2 операций.

Теперь сопоставим это с БПФ, которое (N log N) в идеальном случае благодаря умному повторному использованию вычислений - большое улучшение! Тем не менее, классический алгоритм Кули-Тьюки, реализованный в FFTPACK (и используемый SciPy), рекурсивно разбивает преобразование на более мелкие (простые по размеру) куски и показывает это улучшение только для «гладких» длин ввода (длина ввода считается гладкой, когда его наибольший простой фактор мал, как показано на рисунке 4-5). Для больших кусков простого размера алгоритмы Bluestein или Rader могут использоваться в сочетании с алгоритмом Cooley-Tukey, но эта оптимизация не реализована в FFTPACK.7

Давайте проиллюстрируем:

import time

from scipy import fftpack
from sympy import factorint

K = 1000
lengths = range(250, 260)

# Calculate the smoothness for all input lengths
smoothness = [max(factorint(i).keys()) for i in lengths]


exec_times = []
for i in lengths:
    z = np.random.random(i)

    # For each input length i, execute the FFT K times
    # and store the execution time

    times = []
    for k in range(K):
        tic = time.monotonic()
        fftpack.fft(z)
        toc = time.monotonic()
        times.append(toc - tic)

    # For each input length, remember the *minimum* execution time
    exec_times.append(min(times))


f, (ax0, ax1) = plt.subplots(2, 1, sharex=True)
ax0.stem(lengths, np.array(exec_times) * 10**6)
ax0.set_ylabel('Execution time (µs)')

ax1.stem(lengths, smoothness)
ax1.set_ylabel('Smoothness of input length\n(lower is better)')
ax1.set_xlabel('Length of input');


Рисунок 4-5. Время выполнения БПФ в зависимости от гладкости для различной длины ввода

Интуиция заключается в том, что для гладких чисел БПФ можно разбить на множество маленьких кусочков. После выполнения БПФ на первом фрагменте мы можем использовать эти результаты в последующих вычислениях. Это объясняет, почему мы выбрали длину 1024 для наших звуковых фрагментов ранее - она ​​имеет гладкость всего 2, что приводит к оптимальному алгоритму «radix-2 Cooley-Tukey», который вычисляет БПФ с использованием только (N / 2) log2N = 5120 комплексных умножений вместо N2 = 1 048 576. Выбор N = 2m всегда обеспечивает максимально гладкое N (и, следовательно, самое быстрое БПФ).
Дополнительные концепции DFT

Далее мы представляем пару общих концепций, которые стоит знать перед эксплуатацией тяжелого механизма преобразования Фурье, после чего мы решаем еще одну реальную проблему: анализ обнаружения целей в радиолокационных данных.
Частоты и их порядок

По историческим причинам большинство реализаций возвращают массив, в котором частоты варьируются от низких до высоких к низким (см. «Дискретные преобразования Фурье» для дальнейшего объяснения частот). Например, когда мы выполняем реальное преобразование Фурье сигнала всех сигналов, вход, который не имеет изменений и поэтому имеет только самый медленный постоянный компонент Фурье (также известный как «постоянный ток» или постоянный ток, компонент - просто электроника). жаргон для «среднее значение сигнала»), в качестве первой записи:

from scipy import fftpack
N = 10
fftpack.fft(np.ones(N))  # The first component is np.mean(x) * N
Когда мы пробуем FFT на быстро меняющемся сигнале, мы видим высокочастотный компонент:

z = np.ones(10)
z[::2] = -1

print(f'Applying FFT to {z}')
fftpack.fft(z)
Обратите внимание, что БПФ возвращает сложный спектр, который в случае реальных входных сигналов является сопряженным симметричным (то есть симметричным в действительной части и антисимметричным в мнимой части):
x = np.array([1, 5, 12, 7, 3, 0, 4, 3, 2, 8])
X = fftpack.fft(x)

np.set_printoptions(precision=2)

print("Real part:     ", X.real)
print("Imaginary part:", X.imag)

np.set_printoptions()
(И, опять же, напомним, что первым компонентом является np.mean (x) * N.)

Функция fftfreq сообщает нам, на каких частотах мы смотрим
fftpack.fftfreq(10)

Результат говорит нам, что наш максимальный компонент происходил с частотой 0,5 цикла на образец. Это согласуется со входом, где цикл «минус один плюс один» повторяется для каждой второй выборки.

Иногда удобно рассматривать спектр, организованный немного по-другому, от высокого отрицательного к низкому к высокому положительному (на данный момент мы не будем слишком углубляться в понятие отрицательной частоты, кроме как сказать реальное мировая синусоида создается сочетанием положительных и отрицательных частот). Мы перетасовываем спектр, используя функцию fftshift.

Дискретные преобразования Фурье

DFT преобразует последовательность из N одинаково разнесенных действительных или комплексных отсчетов x0, x1, .... xN – 1 функции x (t) времени (или другой переменной, в зависимости от приложения) в последовательность из N комплексных чисел Xk следующим суммированием:



С известными числами Xk обратное ДПФ точно восстанавливает значения выборки xn посредством следующего суммирования:
Учитывая, что ejθ = cosθ + j sinθ, последнее уравнение показывает, что ДПФ разложил последовательность xn в комплексный дискретный ряд Фурье с коэффициентами Xk. Сравнивая ДПФ с непрерывным комплексным рядом Фурье:

ДПФ представляет собой конечный ряд с N слагаемыми, определенными в одинаково разнесенных дискретных случаях угла в интервале [0, 2π), то есть, включая 0 и исключая 2π. Это автоматически нормализует ДПФ, так что время не появляется явно в прямом или обратном преобразовании.

Если исходная функция x (t) ограничена по частоте менее чем половиной частоты дискретизации (так называемая частота Найквиста), интерполяция между значениями выборки, полученными с помощью обратного ДПФ, обычно дает точное восстановление x (t). Если x (t) не ограничено как таковое, обратное ДПФ, как правило, не может использоваться для восстановления x (t) путем интерполяции. Обратите внимание, что этот предел не означает, что не существует методов, которые могут выполнить такую реконструкцию - например, сжатое зондирование или конечную частоту выборки инноваций.
Функция e j2πk | N = (ej2π | N) k = wk принимает дискретные значения от 0 до единичного круга в комплексной плоскости. Функция ej2πkn | N = wkn охватывает времена начала координат, таким образом генерируя гармоники основной синусоиды, для которой n = 1.

То, как мы определили ДПФ, приводит к нескольким тонкостям, когда для четного N.8 функция e j2πkn | N построена для увеличения значений k на рисунке 4-6, для случаев от n = 1 до n = N - 1 для N = 16. Когда k увеличивается от k до k + 1, угол увеличивается на. Когда n = 1, шаг равен. Когда n = N - 1, угол увеличивается на. Поскольку 2π точно один раз по кругу, шаг приравнивается к-то есть, в направлении отрицательной частоты. Компоненты до N / 2 представляют положительные частотные компоненты, а компоненты от N / 2 до N - 1 представляют отрицательные частоты. Приращение угла для компонента N / 2 для N даже продвигается точно наполовину по окружности для каждого приращения k и поэтому может интерпретироваться как положительная или отрицательная частота. Этот компонент DFT представляет частоту Найквиста (то есть половину частоты дискретизации) и полезен для ориентации при просмотре графики DFT.

БПФ, в свою очередь, является просто специальным и высокоэффективным алгоритмом для вычисления ДПФ. Принимая во внимание, что прямое вычисление DFT принимает порядок вычислений N2, алгоритм FFT требует порядка N log N вычислений. FFT стал ключом к широкому использованию DFT в приложениях реального времени и был включен в список 10 лучших алгоритмов двадцатого века журналом IEEE Computing in Science & Engineering в 2000 году.

Давайте рассмотрим частотные компоненты на зашумленном изображении (Рисунок 4-7). Обратите внимание, что, хотя статическое изображение не имеет изменяющегося во времени компонента, его значения изменяются в пространстве. ДПФ применяется одинаково в любом случае.

Сначала загрузите и отобразите изображение:

from skimage import io
image = io.imread('images/moonlanding.png')
M, N = image.shape

f, ax = plt.subplots(figsize=(4.8, 4.8))
ax.imshow(image)

print((M, N), image.dtype)


Не настроить монитор! Изображение, которое вы видите, является реальным, хотя оно явно искажено измерительным или передающим оборудованием.

Чтобы исследовать спектр изображения, мы используем fftn (вместо fft) для вычисления ДПФ, поскольку оно имеет более одного измерения. 2D БПФ эквивалентно переносу 1D БПФ по строкам, а затем по столбцам или наоборот.

F = fftpack.fftn(image)

F_magnitude = np.abs(F)
F_magnitude = fftpack.fftshift(F_magnitude)
Опять же, мы берем журнал спектра, чтобы сжать диапазон значений перед отображением:
f, ax = plt.subplots(figsize=(4.8, 4.8))

ax.imshow(np.log(1 + F_magnitude), cmap='viridis',
          extent=(-N // 2, N // 2, -M // 2, M // 2))
ax.set_title('Spectrum magnitude');

Обратите внимание на высокие значения вокруг начала (середины) спектра - эти коэффициенты описывают низкие частоты или гладкие части изображения, смутный холст фотографии. Высокочастотные составляющие, распределенные по всему спектру, заполняют края и детали. Пики вокруг более высоких частот соответствуют периодическому шуму.

Из фотографии видно, что шум (артефакты измерения) очень периодический, поэтому мы надеемся устранить его, обнулив соответствующие части спектра (Рисунок 4-8).

Изображение с этими подавленными пиками действительно выглядит совсем по-другому!
# Set block around center of spectrum to zero
K = 40
F_magnitude[M // 2 - K: M // 2 + K, N // 2 - K: N // 2 + K] = 0

# Find all peaks higher than the 98th percentile
peaks = F_magnitude < np.percentile(F_magnitude, 98)

# Shift the peaks back to align with the original spectrum
peaks = fftpack.ifftshift(peaks)

# Make a copy of the original (complex) spectrum
F_dim = F.copy()

# Set those peak coefficients to zero
F_dim = F_dim * peaks.astype(int)

# Do the inverse Fourier transform to get back to an image.
# Since we started with a real image, we only look at the real part of
# the output.
image_filtered = np.real(fftpack.ifft2(F_dim))

f, (ax0, ax1) = plt.subplots(2, 1, figsize=(4.8, 7))
ax0.imshow(np.log10(1 + np.abs(F_dim)), cmap='viridis')
ax0.set_title('Spectrum after suppression')

ax1.imshow(image_filtered)
ax1.set_title('Reconstructed image');




Оконная

Если мы рассмотрим преобразование Фурье прямоугольного импульса, мы увидим значительные боковые лепестки в спектре:

x = np.zeros(500)
x[100:150] = 1

X = fftpack.fft(x)

f, (ax0, ax1) = plt.subplots(2, 1, sharex=True)

ax0.plot(x)
ax0.set_ylim(-0.1, 1.1)

ax1.plot(fftpack.fftshift(np.abs(X)))
ax1.set_ylim(-5, 55);


Теоретически, вам потребуется комбинация бесконечно большого числа синусоид (частот), чтобы представить любой резкий переход; коэффициенты, как правило, имели бы такую же структуру боковых лепестков, что и здесь для импульса.

Важно отметить, что ДПФ предполагает, что входной сигнал является периодическим. Если сигнал отсутствует, предполагается, что в самом конце сигнала он возвращается к своему начальному значению. Рассмотрим функцию x (t), показанную здесь:
Мы измеряем сигнал только в течение короткого времени, помеченный Teff. Преобразование Фурье предполагает, что x (8) = x (0) и что сигнал продолжается в виде пунктирной, а не сплошной линии. Это вводит большой скачок на границе с ожидаемыми колебаниями в спектре:
t = np.linspace(0, 1, 500)
x = np.sin(49 * np.pi * t)

X = fftpack.fft(x)

f, (ax0, ax1) = plt.subplots(2, 1)

ax0.plot(x)
ax0.set_ylim(-1.1, 1.1)

ax1.plot(fftpack.fftfreq(len(t)), np.abs(X))
ax1.set_ylim(0, 190);
Вместо ожидаемых двух линий пики разбросаны по спектру.

Мы можем противостоять этому эффекту с помощью процесса, называемого оконным. Исходная функция умножается на оконную функцию, такую как окно Кайзера K (N, β). Здесь мы визуализируем это для β в диапазоне от 0 до 100:

f, ax = plt.subplots()

N = 10
beta_max = 5
colormap = plt.cm.plasma

norm = plt.Normalize(vmin=0, vmax=beta_max)

lines = [
    ax.plot(np.kaiser(100, beta), color=colormap(norm(beta)))
    for beta in np.linspace(0, beta_max, N)
    ]

sm = plt.cm.ScalarMappable(cmap=colormap, norm=norm)

sm._A = []

plt.colorbar(sm).set_label(r'Kaiser $\beta$');

Изменяя параметр β, мы можем изменить форму окна с прямоугольного (β = 0, без окон) на окно, которое генерирует сигналы, которые плавно увеличиваются от нуля и уменьшаются до нуля в конечных точках интервала выборки, производя очень низкий боковые доли (β обычно между 5 и 10) .9

Применяя здесь окно Кайзера, мы видим, что боковые лепестки были резко уменьшены за счет небольшого расширения в основной доле.

Эффект оконного нашего предыдущего примера заметен:

win = np.kaiser(len(t), 5)
X_win = fftpack.fft(x * win)

plt.plot(fftpack.fftfreq(len(t)), np.abs(X_win))
plt.ylim(0, 190);


Реальное применение: анализ данных радара

Линейно-модулированные радиолокаторы FMCW (частотно-модулированная непрерывная волна) широко используют алгоритм FFT для обработки сигналов и предоставляют примеры различных применений FFT. Мы будем использовать фактические данные с радара FMCW, чтобы продемонстрировать одно из таких приложений: обнаружение целей.

Грубо говоря, радар FMCW работает следующим образом (подробнее см. «Простая радиолокационная система FMCW» и рисунок 4-9):
Сигнал с изменением частоты генерируется. Этот сигнал передается антенной, после чего он распространяется наружу от радара. Когда он попадает в объект, часть сигнала отражается обратно на радар, где он принимается, умножается на копию передаваемого сигнала и дискретизируется, превращая его в числа, которые упаковываются в массив. Наша задача - интерпретировать эти цифры, чтобы получить значимые результаты.

    Предыдущий шаг умножения важен. Из школы вспомните тригонометрическую идентичность:


    Таким образом, если мы умножим принятый сигнал на передаваемый сигнал, мы ожидаем, что в спектре появятся две частотные составляющие: одна - это разница в частотах между принятым и переданным сигналом, а другая - сумма их частот.

    Мы особенно заинтересованы в первом, так как это дает нам некоторое представление о том, сколько времени понадобилось сигналу, чтобы отразиться обратно на радар (другими словами, как далеко объект находится от нас!). Мы отбрасываем другое, применяя к сигналу фильтр нижних частот (то есть фильтр, который отбрасывает любые высокие частоты).

Блок-схема простого радара FMCW, в котором используются отдельные передающие и приемные антенны, показана выше. Радар состоит из генератора сигналов, который генерирует синусоидальный сигнал, частота которого изменяется линейно вокруг требуемой частоты передачи. Сгенерированный сигнал усиливается передающим усилителем до требуемого уровня мощности и направляется на передающую антенну через схему сопряжения, где копируется передаваемый сигнал. Передающая антенна излучает передаваемый сигнал в виде электромагнитной волны в узком луче в направлении обнаруживаемой цели. Когда волна сталкивается с объектом, который отражает электромагнитные волны, часть энергии, излучающей цель, отражается обратно в приемник как вторая электромагнитная волна, которая распространяется в направлении радиолокационной системы. Когда эта волна встречает приемную антенну, антенна собирает энергию в энергии волны, падающей на нее, и преобразует ее в флуктуирующее напряжение, которое подается на смеситель. Смеситель умножает принятый сигнал на реплику передаваемого сигнала и выдает синусоидальный сигнал с частотой, равной разности частот между передаваемым и принимаемым сигналами. Фильтр нижних частот гарантирует, что принимаемый сигнал ограничен полосой (т. Е. Не содержит частот, которые нас не интересуют), а усилитель приема усиливает сигнал до подходящей амплитуды для аналого-цифрового преобразователя (АЦП) который передает данные на компьютер.

Подводя итог, отметим, что:

     Данные, поступающие в компьютер, состоят из N выборок (из умноженного отфильтрованного сигнала) с частотой дискретизации fs.
     Амплитуда возвращаемого сигнала варьируется в зависимости от силы отражения (то есть является свойством целевого объекта и расстояния между целью и радаром).
     Измеренная частота является показателем расстояния целевого объекта от радара.

Чтобы начать анализ данных радара, мы сгенерируем несколько синтетических сигналов, после чего обратим внимание на вывод фактического радара.

Напомним, что радар увеличивает свою частоту при передаче со скоростью S Гц / с. По истечении определенного времени t частота будет больше на tS (рис. 4-10). За тот же промежуток времени радиолокационный сигнал прошел d = t / v метров, где v - скорость передаваемой волны по воздуху (примерно такая же, как скорость света, 3 × 108 м / с).

pict

Комбинируя вышеприведенные наблюдения, мы можем рассчитать количество времени, которое понадобится сигналу, чтобы пройти, отскочить и вернуться от цели, находящейся на расстоянии R:
TR = 2R / V

pi = np.pi

# Radar parameters
fs = 78125          # Sampling frequency in Hz, i.e., we sample 78125
                    # times per second

ts = 1 / fs         # Sampling time, i.e., one sample is taken each
                    # ts seconds

Teff = 2048.0 * ts  # Total sampling time for 2048 samples
                    # (AKA effective sweep duration) in seconds.

Beff = 100e6        # Range of transmit signal frequency during the time the
                    # radar samples, known as the "effective bandwidth"
                    # (given in Hz)

S = Beff / Teff     # Frequency sweep rate in Hz/s

# Specification of targets.  We made these targets up, imagining they
# are objects seen by the radar with the specified range and size.

R = np.array([100, 137, 154, 159,  180])  # Ranges (in meter)
M = np.array([0.33, 0.2, 0.9, 0.02, 0.1])  # Target size
P = np.array([0, pi / 2, pi / 3, pi / 5, pi / 6])  # Randomly chosen phase offsets

t = np.arange(2048) * ts  # Sample times

fd = 2 * S * R / 3E8      # Frequency differences for these targets

# Generate five targets
signals = np.cos(2 * pi * fd * t[:, np.newaxis] + P)

# Save the signal associated with the first target as an example for
# later inspection
v_single = signals[:, 0]

# Weigh the signals, according to target size and sum, to generate
# the combined signal seen by the radar.
v_sim = np.sum(M * signals, axis=1)

## The above code is equivalent to:
#
# v0 = np.cos(2 * pi * fd[0] * t)
# v1 = np.cos(2 * pi * fd[1] * t + pi / 2)
# v2 = np.cos(2 * pi * fd[2] * t + pi / 3)
# v3 = np.cos(2 * pi * fd[3] * t + pi / 5)
# v4 = np.cos(2 * pi * fd[4] * t + pi / 6)
#
## Blend them together
# v_single = v0
# v_sim = (0.33 * v0) + (0.2 * v1) + (0.9 * v2) + (0.02 * v3) + (0.1 * v4)


Здесь мы сгенерировали синтетический сигнал vsingle, полученный при взгляде на одну цель (см. Рисунок 4-11). Подсчитав количество циклов, наблюдаемых за данный период времени, мы можем вычислить частоту сигнала и, таким образом, расстояние до цели.

Правда, настоящий радар редко получает только одно эхо. Имитированный сигнал vsim показывает, как будет выглядеть сигнал радара с пятью целями на разных дальностях (включая две близкие друг к другу на 154 и 159 метрах), а vactual (t) показывает выходной сигнал, полученный с помощью фактического радара. Когда мы добавляем несколько эхо-сигналов вместе, результат имеет мало интуитивного смысла (рис. 4-11); до тех пор, пока мы не посмотрим на это более внимательно через объектив ДПФ.
Выходные сигналы приемника: (a) одиночная моделируемая цель, (b) пять моделируемых целей и (c) фактические радиолокационные данные

pict

Внезапно, информация имеет смысл!

Сюжет для | V0 | четко показывает цель на компоненте 67, а для | Vsim | показывает цели, которые произвели сигнал, который был не интерпретируемым во временной области. Реальный радиолокационный сигнал, | Vactual |, показывает большое количество целей между компонентами 400 и 500 с большим пиком в компоненте 443. Это, как представляется, эхо-сигнал от радара, освещающего высокую стену карьера.

Чтобы получить полезную информацию из сюжета, мы должны определить ассортимент! Опять же, мы используем формулу:

В радиолокационной терминологии каждый компонент ДПФ известен как интервальный диапазон.

Это уравнение также определяет разрешение по дальности радара: цели будут различимы только в том случае, если они разделены более чем двумя ячейками дальности, например:

Это фундаментальное свойство всех типов радаров.

Этот результат вполне удовлетворителен, но динамический диапазон настолько велик, что мы можем очень легко пропустить некоторые пики. Давайте возьмем журнал, как и прежде, с спектрограммой:
c = 3e8  # Approximately the speed of light and of
         # electromagnetic waves in air

fig, (ax0, ax1, ax2) = plt.subplots(3, 1)


def dB(y):
    "Calculate the log ratio of y / max(y) in decibel."

    y = np.abs(y)
    y /= y.max()

    return 20 * np.log10(y)


def log_plot_normalized(x, y, ylabel, ax):
    ax.plot(x, dB(y))
    ax.set_ylabel(ylabel)
    ax.grid()


rng = np.arange(N // 2) * c / 2 / Beff

with plt.style.context('style/thinner.mplstyle'):
    log_plot_normalized(rng, V_single[:N // 2], "$|V_0|$ [dB]", ax0)
    log_plot_normalized(rng, V_sim[:N // 2], "$|V_5|$ [dB]", ax1)
    log_plot_normalized(rng, V_actual[:N // 2], "$|V_{\mathrm{actual}}|$ [dB]"
        , ax2)

ax0.set_xlim(0, 300)  # Change x limits for these plots so that
ax1.set_xlim(0, 300)  # we are better able to see the shape of the peaks.
ax2.set_xlim(0, len(V_actual) // 2)
ax2.set_xlabel('range')
pict

Наблюдаемый динамический диапазон значительно улучшен на этих графиках. Например, в реальном сигнале радара уровень шума радара стал видимым (то есть уровень, на котором электронный шум в системе начинает ограничивать способность радара обнаруживать цель).
Оконный, Прикладной

Мы добираемся туда, но в спектре моделируемого сигнала мы все еще не можем различить пики на 154 и 159 метрах. Кто знает, чего нам не хватает в реальном сигнале! Чтобы отточить пики, мы вернемся к нашему набору инструментов и воспользуемся окнами.

Вот сигналы, используемые до сих пор в этом примере, оконные с окном Кайзера с β = 6,1:
f, axes = plt.subplots(3, 1, sharex=True, figsize=(4.8, 2.8))

t_ms = t * 1000  # Sample times in milli-second

w = np.kaiser(N, 6.1)  # Kaiser window with beta = 6.1

for n, (signal, label) in enumerate([(v_single, r'$v_0 [V]$'),
                                     (v_sim, r'$v_5 [V]$'),
                                     (v_actual, r'$v_{\mathrm{actual}} [V]$')]):
    with plt.style.context('style/thinner.mplstyle'):
        axes[n].plot(t_ms, w * signal)
        axes[n].set_ylabel(label)
        axes[n].grid()

axes[2].set_xlim(0, t_ms[-1])
axes[2].set_xlabel('Time [ms]');
pict

И соответствующие БПФ, или «следы дальности», в терминах радара:

V_single_win = np.fft.fft(w * v_single)
V_sim_win = np.fft.fft(w * v_sim)
V_actual_win = np.fft.fft(w * v_actual)

fig, (ax0, ax1,ax2) = plt.subplots(3, 1)

with plt.style.context('style/thinner.mplstyle'):
    log_plot_normalized(rng, V_single_win[:N // 2],
                        r"$|V_{0,\mathrm{win}}|$ [dB]", ax0)
    log_plot_normalized(rng, V_sim_win[:N // 2],
                        r"$|V_{5,\mathrm{win}}|$ [dB]", ax1)
    log_plot_normalized(rng, V_actual_win[:N // 2],
                        r"$|V_\mathrm{actual,win}|$ [dB]", ax2)

ax0.set_xlim(0, 300)  # Change x limits for these plots so that
ax1.set_xlim(0, 300)  # we are better able to see the shape of the peaks.

ax1.annotate("New, previously unseen!", (160, -35), xytext=(10, 15),
             textcoords="offset points", color='red', size='x-small',
             arrowprops=dict(width=0.5, headwidth=3, headlength=4,
                             fc='k', shrink=0.1));

